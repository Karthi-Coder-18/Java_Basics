JVM -> JAVA VIRTUAL MACHINE

JRE: Java Run Time Environment does contains the JVM and Java API libs which are required to run and execute the program.

JDK will have the Compiler to compile the code to bytecode and JRE will take care of executing the code. 



-> The JVM acts as an Interpreter and takes the java byte code provided by java compiler & then reads the statements from bytecode and then sends the instructions to machine in machine code format.

-> When the compilation process starts [javac] the java compiler will take the [.java] extension files and then converts it into a [.class] format which is java bytecode.

-> JVM will take this [.class] file and then reads the statements, uses the pre-defined machine code library to generate the machine code and send the instructions to machine.

what is JIT [Just-in-time-compilation] in java?

-> javac hello.java - compiles the java class into an java byte code format
-> java hello - Here java is the java interpreter that which creates an instance of JVM, i.e. CPU loads the JVM into memory as soon as java interpreter creates an instance of JVM & the JVM executes the program onto the machine.




-> JAVA is a Platform Independent Language which can run it's program on any platform / OS.
-> RUN TIME - This is when the program is actually executed onto the machine
-> One JVM instance can run only one Java application.

Core responsibilities of JVM

1. Loading and interpreting Java byte code
2. Security
3. Automatic memory management using Garbage collection




JIT Compiler [ Just In Time compiler ] JIT is a JVM component

-> JIT compiler identifies the frequently executed byte code which is also called as "HOTSPOTS"
-> JIT will convert these hotspots into machine code and stores as a machine code cache.
-> In this way JIT utilizes the frequently compiled code to run the programs faster!!
->  This process is also called as "Dynamic Compilation"

-> Once the JIT compiler understands that the code which is being interpreted by JVM is being repeated multiple times then it creates it's own version of that Bytecode as machine code.
After that the JIT will directly runs the machine code on the hardware instead of interpreting the Byte code.




